%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ff771ccdf4150419d9ff4d342b069aae, type: 3}
  m_Name: G4-AboutAStar
  m_EditorClassIdentifier: 
  m_Paragraphs:
    m_Items:
    - m_Type: 0
      Title:
        m_Untranslated: A* Details
      Text:
        m_Untranslated: "Let\u2019s have a look at the Path Follower code to understand
          how this behaviour works.\r\nFirst, the private member variables for storing
          useful information about the pathfinding. We keep a list of all the nodes
          in the game world:\r\n<code>\r\nList&lt;PathNode> nodes;\t\r\n</code>\r\nWe
          keep a list representing the nodes to traverse in order to reach the target:\r\n<code>\r\nList&lt;PathNode>
          solvedPathNodes;\r\n</code>\r\nWe keep a track of the node which is closest
          to our target (we check to see if this changes, and if so calculate a new
          path):\r\n<code>\r\nPathNode currentNodeClosestToTarget;\r\n</code>\r\nWe
          store which node is the one we are currently travelling towards\r\n<code>\r\nPathNode
          nextNode;\r\n</code>\r\nThe <c>Start</c> function simply grabs all of the
          nodes in the scene, and then calculates a path to the target. The function
          uses the term \u201CIf Necessary\u201D because when called repeatedly every
          frame it won\u2019t necessarily update the path. In the case of it being
          called for the first time, it is guaranteed to generate a new path (provided
          there is a target to track):\r\n<code>\r\nprotected override void Start()\r\n{\r\n   
          base.Start();\r\n\r\n    GetAllNodes();\r\n    UpdateTargetNodeIfNecessary();\r\n}\r\n</code>\r\nThe
          main part of this code is in the FixedUpdate function. Again we are inheriting
          from <asset>Mover</asset>, so the goal is to set the <c>desiredVelocity</c>
          in this function, so that when we call <c>base.Move()</c> we apply the
          velocity.\r\nThe first thing the script does every frame is check to see
          if we should calculate a new path to the target (this happens if the closest
          node to the target is different to what it was on the last frame):\r\n<code>\r\nif
          (target != null)\r\n{\r\n    UpdateTargetNodeIfNecessary();\r\n}\r\n</code>\r\nThen,
          if there is a currently valid path to follow, we move towards the next
          node in the path (<c>MoveToNode()</c> sets the <c>desiredVelocity</c> of
          the <c>Mover</c>):\r\n<code>\r\nif (solvedPathNodes != null AND solvedPathNodes.Count
          &gt; 0)\r\n{\r\n    nextNode = solvedPathNodes[0];\r\n    MoveToNode(nextNode);
          \r\n</code>\r\nOnce we reach that next node, we remove that node from the
          list and continue on to the next node\r\n<code>\r\n    if (DistanceBetween(nextNode,
          transform) &lt; 0.5f)\r\n    {\r\n        RemoveFirstNodeInPath();\r\n   
          }\r\n}\r\n</code>\r\nOnce we run out of nodes in the path then it means
          there are no more nodes between the enemy and the target point\u2014at
          which point we should then just move towards the target  (<c>MoveToTarget</c>
          sets the <c>desiredVelocity</c> of the <c>Mover</c>, and works the same
          way that the <c>Seek</c> behaviour from the start of the practical works):\r\n<code>\r\nelse
          if (target != null)\r\n{\r\n    MoveToTarget();\r\n}\r\n</code>\r\nFinally,
          the base function is called so that the velocity from the various MoveTo
          functions are applied\r\n<code>\r\nbase.Move();\r\n</code>\r\nA lot of
          the code in the <c>FixedUpdate</c> function reads a bit like pseudo code,
          with large chunks abstracted away to a function call. This makes the code
          relatively easy to understand, and even easier to replace the specific
          implementation of any one of those functions without impacting the basic
          algorithm used by the code. Explore the rest of the A-Star follower code
          (it is commented) to see the specifics of the functions which have been
          called from <c>FixedUpdate</c>."
      m_PollItems: []
      m_PollCorrectItemIndexes: 00000000
      m_Tutorial: {fileID: 0}
      m_Image: {fileID: 0}
      m_Video: {fileID: 0}
      m_CriteriaCompletion: 0
      m_Criteria:
        m_Items: []
      m_PossibleErrors: []
      m_MaskingSettings:
        m_MaskingEnabled: 0
        m_UnmaskedViews: []
      m_Summary: 
      m_Description: 
      m_InstructionBoxTitle: 
      m_InstructionText: 
      m_TutorialButtonText: 
      codeBlockText: 
  m_CameraSettings:
    m_CameraMode: 0
    m_FocusMode: 0
    m_Orthographic: 0
    m_Size: 0
    m_Pivot: {x: 0, y: 0, z: 0}
    m_Rotation: {x: 0, y: 0, z: 0, w: 0}
    m_FrameObject:
      m_SceneGuid: 
      m_GameObjectGuid: 
      m_SerializedComponentType:
        m_TypeName: 
      m_ComponentIndex: 0
      m_AssetObject: {fileID: 0}
      m_Prefab: {fileID: 0}
    m_Enabled: 0
  NextButton:
    m_Untranslated: Next
  DoneButton:
    m_Untranslated: Done
  m_NextButton: Next
  m_DoneButton: Done
  m_CompletedSound: {fileID: 0}
  m_autoAdvance: 0
  m_OnBeforePageShown:
    m_PersistentCalls:
      m_Calls: []
  m_OnAfterPageShown:
    m_PersistentCalls:
      m_Calls: []
  m_OnBeforeTutorialQuit:
    m_PersistentCalls:
      m_Calls: []
  m_OnTutorialPageStay:
    m_PersistentCalls:
      m_Calls: []
